<?php

use Drupal\Core\Entity\RevisionLogInterface;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\ra_article\ArticleDetailFetchService;

/**
 * Implements hook_cron().
 *
 * Fetch the article detail.
 */
function ra_article_scrape_article_cron() {
  /** @var \Drupal\ra_article\ArticleDetailFetchService $articleDetailFetch */
  $articleDetailFetch = \Drupal::service('ra_article.article_detail_fetch');
  $articleNids = $articleDetailFetch->getArticleNidsToFetch();
  $articleDetailFetch->fetchArticleDetail($articleNids);
}

/**
 * Implements hook_cron().
 *
 * Fetch open article of a seller.
 */
function ra_article_scrape_seller_articles_cron() {
  /** @var \Drupal\ra_article\SellerArticlesServiceInterface $sellerArticleService */
  $sellerArticleService = \Drupal::service('ra_article.seller_articles');
  $sellerArticleService->fetchSellerArticles();
}

/**
 * Implements hook_cron().
 *
 * Fills thew queue with the open article pages.
 */
function ra_article_scrape_seller_articles_init_cron() {
  /** @var \Drupal\ra_article\SellerArticlesServiceInterface $sellerArticleService */
  $sellerArticleService = \Drupal::service('ra_article.seller_articles');
  $sellerArticleService->createSellerArticleQueue();
}

/**
 * Changes article status to scrape.
 */
function _change_article_status_cron(): void {
  $timestamp = strtotime('-3 days', time());
  $datetime = date('Y-m-d\Th:m:s', $timestamp);

  $database = \Drupal::database();
  $query = $database->select('node__field_article_end_date', 'ed');
  $query->fields('ed', ['entity_id'])
    ->condition('ed.field_article_end_date_value', $datetime, '<=')
    ->condition('cm.moderation_state', 'open')
    ->range(0, 10)
    ->join('content_moderation_state_field_data', 'cm', 'ed.entity_id=cm.content_entity_id');

  $articleNids = $query->execute()->fetchAll();
  if (empty($articleNids)) {
    return;
  }

  foreach ($articleNids as $nid) {
    $article = Node::load($nid->entity_id);
    $article->set('moderation_state', ArticleDetailFetchService::STATE_FOR_SCRAPE);
    if ($article instanceof RevisionLogInterface) {
      $article->setRevisionUserId(1);
      $article->setRevisionLogMessage('Changed to ' . ArticleDetailFetchService::STATE_FOR_SCRAPE);
    }
    $article->setChangedTime(time());
    $article->save();
  }
}

/**
 * Determine if article was sold or not and create sale entities.
 */
function _process_article_status_cron() {
  $database = \Drupal::database();
  $query = $database->select('node_field_data', 'n');
  $query->fields('n', ['nid'])
    ->condition('n.type', 'article')
    ->condition('cm.moderation_state', ArticleDetailFetchService::STATE_SUCCESSFUL_FETCH)
    ->range(0, 500)
    ->join('content_moderation_state_field_data', 'cm', 'n.nid=cm.content_entity_id');

  $articleNids = $query->execute()->fetchAll();
  if (empty($articleNids)) {
    return;
  }

  foreach ($articleNids as $nid) {
    $article = Node::load($nid->nid);
    if (!$article instanceof NodeInterface) {
      \Drupal::logger('ra_article')->error('No entity in _process_article_status_cron');
      $article->setRevisionLogMessage('Changed to ' . ArticleDetailFetchService::STATE_ERROR_FETCH);
      $article->set('moderation_state', ArticleDetailFetchService::STATE_ERROR_FETCH);
      $article->save();
    }

    // Workaround, since loading value vie entity breaks everything.
    $query = $database->select('node__field_article_raw_json', 'raw');
    $query->fields('raw', ['field_article_raw_json_value'])->condition('raw.entity_id', $article->id());
    $jsonData = $query->execute()->fetchAssoc();
    $jsonData = $jsonData['field_article_raw_json_value'];
    if (@unserialize($jsonData) !== TRUE && preg_match('/^[aOs]:/', $jsonData)) {
      $jsonData = preg_replace_callback('/s\:(\d+)\:\"(.*?)\";/s', function ($matches) {
        return 's:' . strlen($matches[2]) . ':"' . $matches[2] . '";';
      }, $jsonData);
    }

    $jsonData = unserialize($jsonData);
    if (!$jsonData) {
      \Drupal::logger('ra_article')->error('Empty data in _process_article_status_cron');
      $article->setRevisionLogMessage('Changed to ' . ArticleDetailFetchService::STATE_ERROR_FETCH);
      $article->set('moderation_state', ArticleDetailFetchService::STATE_ERROR_FETCH);
      $article->save();
    }

    $remainingTime = $jsonData['props']['initialState']['pdp']['article']['offer']['remaining_time'];
    // Auction is finished.
    if ($remainingTime < 0) {
      // Close article.
      $article->setRevisionLogMessage('Changed to ' . ArticleDetailFetchService::STATE_CLOSED);
      $article->set('moderation_state', ArticleDetailFetchService::STATE_CLOSED);
      $article->save();

      $price = $jsonData['props']['initialState']['pdp']['article']['offer']['price'];
      $initialQuantity = $jsonData['props']['initialState']['pdp']['article']['offer']['initial_quantity'];
      $remainingQuantity = $jsonData['props']['initialState']['pdp']['article']['offer']['remaining_quantity'];
      $soldItems = $initialQuantity - $remainingQuantity;

      // Determine how many items has been sold and create Sale node if necessary.
      // Maybe we created some Sale node already in the further process.
      /** @var \Drupal\node\NodeStorage $nodeStorage */
      $nodeStorage = \Drupal::service('entity_type.manager')->getStorage('node');
      $existingSaleNodes = $nodeStorage->loadByProperties([
        'type' => 'sale',
        'field_sale_article_ref' => $article->id(),
      ]);

      $saleNodeToCreate = $soldItems - count($existingSaleNodes);
      for ($i = 0; $i < $saleNodeToCreate; $i++) {
        $sale = Node::create([
          'type' => 'sale',
          'title' => $article->getTitle(),
          'field_sale_article_ref' => $article,
          'field_sale_price' => (float) $price,
        ]);
        $sale->setRevisionUserId(1);
        $sale->setRevisionLogMessage('Created');
        $sale->save();
      }
    }
  }
}


